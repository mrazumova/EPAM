Задание для тренинга #01 (часть 3)
Использование массивов в Java.
Алгоритмы сортировки и поиска.

Требования
1) Для каждого отдельного задания вначале рекомендуется разработать блок-
схему вычислительного алгоритма. Для проектирования блок-схем алгоритмов
используйте соответствующее ПО или бумагу.
2) При реализации компонентов приложения необходимо по максимуму
пытаться разрабатывать универсальный, масштабируемый и легко
поддерживаемый и читаемый код.
3) Также рекомендуется придерживаться Single Responsibility Principle, SRP
(принципа единственной ответственности): у каждого пакета, класса или метода
должна быть только одна ответственность (цель), т.е. должна быть только одна
причина изменить в дальнейшем соответствующий программный код.
4) Создаваемые классы должны иметь «адекватные» имена и должны быть
грамотно структурированы по соответствующим пакетам, которые также
должны иметь «адекватные» названия и начинаться с:
by.epam.javatraining.studentname.tasks. maintask01....
5) Если логически не подразумевается или в задании иного не указано, то
входными и выходными данными являются вещественные числа (числа с
плавающей запятой).
6) Для задания размерности контейнеров и конкретных его элементов
необходимо использовать несколько приёмов: «хардкод», чтение из файла, …).
7) Для генерирования случайных чисел воспользуйтесь методами объекта
класса java.util.Random.
8) Необходимо предусмотреть контейнеры, как с фиксированным начальным
размером, так и их динамически расширяемые варианты.
9) Для проверки работоспособности логики приложения необходимо
разработать модульные тесты с использование тестового фреймворка Apache
jUnit версии 4.0 и младше.
10) Для журналирования (логирования) необходимо использовать библиотеку
Apache Log4J 2.
11) Программа должна обязательно быть снабжена комментариями, в которых
необходимо указать краткое предназначение программы, версию программы,
ФИО разработчика, дату разработки. Исходный текст классов и
демонстрационной программы рекомендуется также снабжать комментариями.
Язык интерфейса приложения и комментариев должен быть обязательно
английский.
12) Дополнительно определите сложность реализованных алгоритмов.

13) Работа с консолью должна быть настолько минимальной, насколько это
возможно и только для варианта цельной программы. Для всех остальных
случаев проверки работоспособности приложения необходимо запускать
соответствующие разработанные тесты.
14) При разработке программ придерживайтесь соглашений по написанию кода
на JAVA (Java Code-Convention).

Основное задание
Задан вектор размера N. Необходимо выполнить следующие действия:
 найти экстремальные значения (минимальный и максимальный элементы)
данного вектора, если таких элементов нет, то возвратить false;
 найти среднеарифметическое и среднегеометрическое значения всех
элементов вектора;
 проверить, находятся ли все элементы вектора в упорядоченном виде (т.е.
отсортированы ли элементы по возрастанию или убыванию);
 найти позицию первого встретившегося локального минимума (максимума), а
если таких элементов нет, то возвратить false (локальный минимум это элемент,
который меньше любого из своих соседей; локальный максимум – это элемент,
который больше любого из своих соседей);
 реализовать для элементов вектора два алгоритма поиска: линейный или
последовательный (linear or sequential search) и двоичный или бинарный (binary
search);
 реверсировать все элементы вектора (при решении данного задания не
рекомендуется задействовать дополнительную память);
 реализовать несколько алгоритмов сортировок элементов вектора по
возрастанию и убыванию (рекомендуется для реализации как минимум
следующие: сортировка обменом или пузырьковая сортировка (bubble sort), а
также её улучшенные версии; сортировка вставками (insertion sort); сортировка
выбором (selection sort); сортировка слиянием (merge sort) и быстрая сортировка
(quick sort).
Одни из многих полезных ссылок по сортировкам:
https://proglib.io/p/sort-algorithms/
Дополнительное задание
Задана матрица размера N x M. Необходимо выполнить следующие действия:
 найти экстремальные значения (минимальный и максимальный элементы)
данной матрицы;
 найти среднеарифметическое и среднегеометрическое значения всех
элементов матрицы;
 проверить, является ли матрица симметричной относительно главной (или
побочной) диагонали.
 найти позицию первого встретившегося локального минимума (максимума), а
если таких элементов нет, то возвратить false (локальный минимум это элемент,
который меньше любого из своих соседей; локальный максимум – это элемент,
который больше любого из своих соседей);
 транспонировать квадратную матрицу (при решении данного задания не
рекомендуется задействовать дополнительную память).
